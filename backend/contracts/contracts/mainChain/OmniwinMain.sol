// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBase.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {IRouterClient} from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";
import {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";

import "hardhat/console.sol";

contract Omniwin is ReentrancyGuard, VRFConsumerBase, CCIPReceiver {
    uint256 maxDeadlineDuration = 30 days;
    uint48 platformFeePercentage = 600;

    address public usdcContractAddress;

    //CCIP
    address immutable link;
    address immutable router;

    //Chainlink VRF v1
    bytes32 internal immutable keyHash; // chainlink
    uint256 internal immutable fee; // fee paid in LINK to chainlink. 0.1 in Rinkeby, 2 in mainnet

    enum STATUS {
        ACCEPTED, // the seller stakes the nft for the raffle
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // the operator sets a winner
        ENDED, // the raffle is finished, and NFT and funds were transferred
        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund
    }

    enum ENTRY_TYPE {
        ONLY_DIRECTLY,
        ONLY_EXTERNAL_CONTRACT,
        MIXED
    }

    enum ASSET_TYPE {
        ERC20,
        ERC721,
        ETH,
        CCIP
    }
    enum MESSAGE_TYPE {
        CREATE_RAFFLE_FROM_SIDECHAIN,
        CREATE_RAFFLE_ACK,
        BUY_ENTRY,
        CREATE_RAFFLE_FROM_MAINCHAIN
    }

    // event sent when the random number is generated by the VRF
    event RandomNumberCreated(
        uint256 indexed idFromMetawin,
        uint256 randomNumber,
        uint256 normalizedRandomNumber
    );
    // Event sent when the raffle is created by the operator
    event RaffleStarted(
        uint256 indexed raffleId,
        address indexed nftAddress,
        uint256 indexed nftId,
        ASSET_TYPE assetType
    );

    event CreateRaffleToSidechain(
        uint256 indexed raffleId,
        address indexed receiver,
        uint64 indexed chainSelector,
        uint256 gasLimit,
        bool strict,
        bytes32 messageId
    );
    // Event sent when the owner of the nft stakes it for the raffle
    // event RaffleStarted(uint256 indexed raffleId, address indexed seller);
    // Event sent when the raffle is finished (either early cashout or successful completion)
    event RaffleEnded(
        uint256 indexed raffleId,
        address indexed winner,
        uint256 amountRaised,
        uint256 randomNumber
    );
    // Event sent when one or more entries are sold (info from the price structure)
    event EntrySold(
        uint256 indexed raffleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId,
        bytes32 messageId
    );

    // Event sent when a free entry is added by the operator
    event FreeEntry(
        uint256 indexed raffleId,
        address[] buyer,
        uint256 amount,
        uint256 currentSize
    );

    // Event sent when a raffle is asked to cancel by the operator
    event RaffleCancelled(uint256 indexed raffleId, uint256 amountRaised);
    // The raffle is closed successfully and the platform receives the fee
    event FeeTransferredToPlatform(
        uint256 indexed raffleId,
        uint256 amountTransferred
    );
    // When the raffle is asked to be cancelled and 30 days have passed, the operator can call a method
    // to transfer the remaining funds and this event is emitted
    event RemainingFundsTransferred(
        uint256 indexed raffleId,
        uint256 amountInWeis
    );
    // When the raffle is asked to be cancelled and 30 days have not passed yet, the players can call a
    // method to refund the amount spent on the raffle and this event is emitted
    event Refund(
        uint256 indexed raffleId,
        uint256 amountInWeis,
        address indexed player
    );
    event EarlyCashoutTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event SetWinnerTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event StatusChangedInEmergency(uint256 indexed raffleId, uint256 newStatus);
    // Emitted when an entry is cancelled
    event EntryCancelled(
        uint256 indexed raffleId,
        uint256 amountOfEntriesCanceled,
        address player
    );

    event AssetsReclaimed(uint256 indexed raffleId, address indexed seller);

    event RaffleCreatedFromSidechain(
        uint256 raffleId,
        uint128 minimumFundsInWei,
        PriceStructure[] prices,
        uint256 deadline,
        address seller,
        bytes32 messageId
    );

    event AckRaffleCreationFromSidechain(
        uint256 raffleId,
        address receiver,
        bytes32 messageIdSourceChain,
        bytes32 messageId
    );

    struct RaffleCreationAckParams {
        address receiver;
        MESSAGE_TYPE messageType;
        bytes32 messageIdSourceChain;
        uint256 raffleId;
        Client.Any2EVMMessage message;
        uint256 deadline;
    }

    struct RandomResult {
        uint256 randomNumber; // random number generated by chainlink.
        uint256 nomalizedRandomNumber; // random number % entriesLength + 1. So between 1 and entries.length
    }

    struct RaffleInfo {
        uint256 id; // raffleId
        uint256 size; // length of the entries array of that raffle
    }

    /* every raffle has an array of price structure (max size = 5) with the different 
    prices for the different entries bought. The price for 1 entry is different than 
    for 5 entries where there is a discount*/
    struct PriceStructure {
        uint48 numEntries;
        uint256 price;
    }

    // Every raffle has a funding structure.
    struct FundingStructure {
        uint128 minimumFundsInWei;
    }

    // In order to calculate the winner, in this struct is saved for each bought the data
    struct EntriesBought {
        uint48 currentEntriesLength; // current amount of entries bought in the raffle
        address player; // wallet address of the player
        uint48 priceStructureId; // id of the price structure
    }

    // Main raffle data struct
    struct RaffleStruct {
        uint48 cancellingDate;
        uint256 prizeNumber; // number (can be a percentage, an id, an amount, etc. depending on the competition)
        address prizeAddress; // address of the prize
        address winner; // address of thed winner of the raffle. Address(0) if no winner yet
        address seller; // address of the seller of the NFT
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
        ASSET_TYPE assetType; // type of the asset. Can be ERC20, ERC721, ETH
        uint256 deadline; // deadline to set a winner
    }

    struct EntryInfoStruct {
        STATUS status; // status of the raffle.
        uint48 entriesLength; // to easy frontend, the length of the entries array is saved here
        uint256 amountRaised; // funds raised so far in wei
    }

    struct SChains {
        address ccnsReceiverAddress;
        uint256 gasLimit;
        bool strict;
        uint64 chainSelector;
    }

    error EntryNotAllowed(string errorType);
    error CreateRaffleError();
    error PriceStructureError();
    error DeadlineExceedsMaximum();
    error CreateRaffleFromSidechainError(string errorType);
    error InsufficientLinkBalance();
    error DirectCCIPRafflesNotAllowed();
    error NotTheSeller();
    error NotTheOwner();
    error NotTheNFTOwner();
    error ContractNotApproved();
    error AllowanceError();
    error TransferFailed();
    error ETHPrizeAmountMismatch();
    error RaffleDeadlineNotPassed();
    error MinimumFundingGoalMet();
    error AlreadyClaimedRefund();
    error NoRefundAvailable();
    error FailedToSendRefund();
    error OnlySellerCanReclaim();
    error FailedToSendERC20Prize();
    error FailedToSendERC721Prize();
    error FailedToSendEthPrize();
    error NoContractsAllowed();
    error NotInAcceptedStatus();
    error IncorrectUSDCAmount();
    error USDCAllowanceTooLow();
    error USDCTransferFailed();
    error RaffleInWrongStatus();
    error FailedToSendPlatformFee();
    error FailedToSendPayoutToSeller();
    error NotEnoughFundsRaised();
    error WrongStatus();
    error FailSendEthToOW();
    error EntryDoesNotBelongToPlayer();
    error NumEntriesIsZero();
    error DuplicateChainSelectorError();
    error DestinationChainNotAllowlisted();
    error SourceChainNotAllowlisted(); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowlisted(); // Used when the sender has not been allowlisted by the contract owner.

    mapping(uint256 => RandomResult) public requests;
    // map the requestId created by chainlink with the raffle info passed as param when calling getRandomNumber()
    mapping(bytes32 => RaffleInfo) public chainlinkRaffleInfo;

    mapping(uint256 => PriceStructure[]) public pricesList;
    mapping(uint256 => FundingStructure) public fundingList;
    mapping(uint256 => EntriesBought[]) public entriesList;

    //CCIP
    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    // The main structure is an array of raffles
    RaffleStruct[] public raffles;

    // The main structure is an array of raffles
    EntryInfoStruct[] public rafflesEntryInfo;

    mapping(uint256 => mapping(address => bool)) public hasClaimedRefund;

    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR");

    // address of the wallet controlled by the platform that will receive the platform fee
    address payable public destinationWallet =
        payable(0x52a032cF59eA274f9D745f29b6D514fe95Ba192D);

    address public owner;

    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee,
        address _router
    )
        VRFConsumerBase(
            _vrfCoordinator, // VRF Coordinator
            _linkToken // LINK Token
        )
        CCIPReceiver(_router)
    {
        owner = msg.sender;

        link = _linkToken;
        router = _router;

        unchecked {
            uint256 _fee;
            keyHash = _keyHash;
            if (_mainetFee == true)
                _fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
            else _fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
            fee = _fee;
        }
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted();
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowlisted();
        if (!allowlistedSenders[_sender]) revert SenderNotAllowlisted();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external {
        if (!isOwner()) revert NotTheOwner();
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain for transactions.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external {
        if (!isOwner()) revert NotTheOwner();
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    function allowlistSender(address _sender, bool allowed) external {
        if (!isOwner()) revert NotTheOwner();
        allowlistedSenders[_sender] = allowed;
    }

    function isOwner() internal view returns (bool) {
        return msg.sender == owner;
    }

    function callVRFAndGetRequestId() internal returns (bytes32 requestId) {
        if (LINK.balanceOf(address(this)) < fee) {
            revert InsufficientLinkBalance();
        }

        bytes32 result = requestRandomness(keyHash, fee);
        return result;
    }

    /// @dev this is the method that will be called by the smart contract to get a random number
    /// @param _id Id of the raffle
    /// @param _entriesSize length of the entries array of that raffle
    /// @param _requestId id generated by Chainlink
    function getRandomNumber(
        uint256 _id,
        uint256 _entriesSize,
        bytes32 _requestId
    ) internal {
        chainlinkRaffleInfo[_requestId] = RaffleInfo({
            id: _id,
            size: _entriesSize
        });
    }

    /// @dev Callback function used by VRF Coordinator. Is called by chainlink
    /// the random number generated is normalized to the size of the entries array, and an event is
    /// generated, that will be listened by the platform backend to be checked if corresponds to a
    /// member of the MW community, and if true will call transferNFTAndFunds
    /// @param requestId id generated previously (on method getRandomNumber by chainlink)
    /// @param randomness random number (huge) generated by chainlink
    function fulfillRandomness(
        bytes32 requestId,
        uint256 randomness
    ) internal override {
        // randomness is the actual random number. Now extract from the aux map the original param id of the call
        RaffleInfo memory raffleInfo = chainlinkRaffleInfo[requestId];
        // save the random number on the map with the original id as key
        uint256 normalizedRandomNumber = (randomness % raffleInfo.size) + 1;

        RandomResult memory result = RandomResult({
            randomNumber: randomness,
            nomalizedRandomNumber: normalizedRandomNumber
        });

        requests[raffleInfo.id] = result;

        // send the event with the original id and the random number
        emit RandomNumberCreated(
            raffleInfo.id,
            randomness,
            normalizedRandomNumber
        );

        transferPrizesAndFunds(raffleInfo.id, normalizedRandomNumber);
    }

    /// @param _desiredFundsInWeis the amount the seller would like to get from the raffle
    /// @param _collateralAddress The address of the NFT of the raffle
    /// @param _collateralId The id of the NFT (ERC721)
    /// @param _minimumFundsInWei The mininum amount required for the raffle to set a winner
    /// @param _prices Array of prices and amount of entries the customer could purchase
    //   /// @param _commissionInBasicPoints commission for the platform, in basic points
    /// @notice Creates a raffle
    /// @dev creates a raffle struct and push it to the raffles array. Some data is stored in the funding data structure
    /// sends an event when finished
    /// @return raffleId
    function _createRaffle(
        address _prizeAddress,
        uint256 _prizeNumber,
        uint128 _minimumFundsInWei,
        PriceStructure[] memory _prices,
        ASSET_TYPE _assetType,
        uint256 _deadlineDuration,
        address seller,
        SChains[] memory _chainSelectors
    ) internal returns (uint256) {
        if (_deadlineDuration > maxDeadlineDuration) {
            revert DeadlineExceedsMaximum();
        }

        //Prize is held on sidechain
        if (_assetType != ASSET_TYPE.CCIP) {
            // Handle the transfer and ownership validation based on asset type
            handleAssetTransferAndValidation(
                _prizeAddress,
                _prizeNumber,
                _assetType
            );
        }

        raffles.push(
            RaffleStruct({
                cancellingDate: 0,
                prizeNumber: _prizeNumber,
                prizeAddress: _prizeAddress,
                winner: address(0),
                seller: seller,
                randomNumber: 0,
                assetType: _assetType,
                deadline: block.timestamp + _deadlineDuration
            })
        );

        saveEntryInfo();

        uint256 raffleId = raffles.length - 1;
        uint256 prizesLength = _prices.length;
        if (prizesLength == 0) revert PriceStructureError();

        for (uint256 i = 0; i < _prices.length; ++i) {
            if (_prices[i].numEntries == 0) revert NumEntriesIsZero();

            pricesList[raffleId].push(_prices[i]);
        }

        fundingList[raffleId] = FundingStructure({
            minimumFundsInWei: _minimumFundsInWei
        });

        if (_chainSelectors.length == 0) {
            emit RaffleStarted(
                raffleId,
                _prizeAddress,
                _prizeNumber,
                _assetType
            );
            return raffleId;
        }

        // Check for duplicate chainSelectors
        for (uint256 i = 0; i < _chainSelectors.length; i++) {
            for (uint256 j = i + 1; j < _chainSelectors.length; j++) {
                if (
                    _chainSelectors[i].chainSelector ==
                    _chainSelectors[j].chainSelector
                ) {
                    revert DuplicateChainSelectorError();
                }
            }
        }

        // Check if each chainSelector is allowlisted
        for (uint256 i = 0; i < _chainSelectors.length; i++) {
            if (
                !allowlistedDestinationChains[_chainSelectors[i].chainSelector]
            ) {
                revert DestinationChainNotAllowlisted();
            }
        }

        for (uint256 i = 0; i < _chainSelectors.length; i++) {
            SChains memory currentChain = _chainSelectors[i];
            MESSAGE_TYPE messageType = MESSAGE_TYPE
                .CREATE_RAFFLE_FROM_MAINCHAIN;

            Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
                receiver: abi.encode(currentChain.ccnsReceiverAddress),
                data: abi.encode(
                    messageType,
                    _prices,
                    block.timestamp + _deadlineDuration,
                    raffleId
                ),
                tokenAmounts: new Client.EVMTokenAmount[](0),
                extraArgs: Client._argsToBytes(
                    // Additional arguments, setting gas limit
                    Client.EVMExtraArgsV1({gasLimit: currentChain.gasLimit})
                ),
                feeToken: link
            });

            uint256 feeCCIP = IRouterClient(router).getFee(
                currentChain.chainSelector,
                message
            );

            bytes32 messageId;

            LinkTokenInterface(link).approve(router, feeCCIP);
            messageId = IRouterClient(router).ccipSend(
                currentChain.chainSelector,
                message
            );

            emit CreateRaffleToSidechain(
                raffleId,
                currentChain.ccnsReceiverAddress,
                currentChain.chainSelector,
                currentChain.gasLimit,
                currentChain.strict,
                messageId
            );
        }

        emit RaffleStarted(raffleId, _prizeAddress, _prizeNumber, _assetType);

        return raffleId;
    }

    function createRaffle(
        address _prizeAddress,
        uint256 _prizeNumber,
        uint128 _minimumFundsInWei,
        PriceStructure[] calldata _prices,
        ASSET_TYPE _assetType,
        uint256 _deadlineDuration,
        SChains[] calldata _chainSelectors
    ) external payable returns (uint256) {
        if (_assetType == ASSET_TYPE.CCIP) {
            revert DirectCCIPRafflesNotAllowed();
        }

        return
            _createRaffle(
                _prizeAddress,
                _prizeNumber,
                _minimumFundsInWei,
                _prices,
                _assetType,
                _deadlineDuration,
                msg.sender,
                _chainSelectors
            );
    }

    /**
     * Create a raffle on the sidechain as a fallback if the main->side transaction fails
     */
    function createRafffleOnSidechainFallback(
        uint256 _raffleId,
        SChains[] calldata _chainSelectors
    ) external {
        RaffleStruct storage raffle = raffles[_raffleId];
        if (raffle.seller != msg.sender) {
            revert NotTheSeller();
        }

        for (uint256 i = 0; i < _chainSelectors.length; i++) {
            SChains memory currentChain = _chainSelectors[i];
            MESSAGE_TYPE messageType = MESSAGE_TYPE
                .CREATE_RAFFLE_FROM_MAINCHAIN;

            Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
                receiver: abi.encode(currentChain.ccnsReceiverAddress),
                data: abi.encode(
                    messageType,
                    pricesList[_raffleId],
                    raffle.deadline,
                    _raffleId
                ),
                tokenAmounts: new Client.EVMTokenAmount[](0),
                extraArgs: "",
                feeToken: link
            });

            uint256 feeCCIP = IRouterClient(router).getFee(
                currentChain.chainSelector,
                message
            );

            bytes32 messageId;

            LinkTokenInterface(link).approve(router, feeCCIP);
            messageId = IRouterClient(router).ccipSend(
                currentChain.chainSelector,
                message
            );

            emit CreateRaffleToSidechain(
                _raffleId,
                currentChain.ccnsReceiverAddress,
                currentChain.chainSelector,
                currentChain.gasLimit,
                currentChain.strict,
                messageId
            );
        }
    }

    function handleAssetTransferAndValidation(
        address _prizeAddress,
        uint256 _prizeNumber,
        ASSET_TYPE _assetType
    ) internal nonReentrant {
        if (_assetType == ASSET_TYPE.ERC721) {
            IERC721 prizeToken = IERC721(_prizeAddress);
            if (prizeToken.ownerOf(_prizeNumber) != msg.sender) {
                revert NotTheNFTOwner();
            }

            if (
                !(prizeToken.isApprovedForAll(msg.sender, address(this)) ||
                    prizeToken.getApproved(_prizeNumber) == address(this))
            ) {
                revert ContractNotApproved();
            }

            prizeToken.transferFrom(msg.sender, address(this), _prizeNumber);
        } else if (_assetType == ASSET_TYPE.ERC20) {
            IERC20 prizeToken = IERC20(_prizeAddress);
            if (
                prizeToken.allowance(msg.sender, address(this)) < _prizeNumber
            ) {
                revert AllowanceError();
            }

            if (
                !prizeToken.transferFrom(
                    msg.sender,
                    address(this),
                    _prizeNumber
                )
            ) {
                revert TransferFailed();
            }
        } else if (_assetType == ASSET_TYPE.ETH) {
            if (msg.value != _prizeNumber) {
                revert ETHPrizeAmountMismatch();
            }
        }
    }

    function setFee(uint48 _fee) external {
        if (!isOwner()) {
            revert NotTheOwner();
        }

        platformFeePercentage = _fee;
    }

    function saveEntryInfo() internal {
        EntryInfoStruct memory entryInfo = EntryInfoStruct({
            status: STATUS.ACCEPTED,
            amountRaised: 0,
            entriesLength: 0
        });
        rafflesEntryInfo.push(entryInfo);
    }

    function claimRefund(uint256 _raffleId) external nonReentrant {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        if (block.timestamp <= raffles[_raffleId].deadline) {
            revert RaffleDeadlineNotPassed();
        }

        if (
            entryInfo.amountRaised >= fundingList[_raffleId].minimumFundsInWei
        ) {
            revert MinimumFundingGoalMet();
        }

        if (hasClaimedRefund[_raffleId][msg.sender]) {
            revert AlreadyClaimedRefund();
        }

        // Ensure there's a check here to prevent out-of-bounds access
        if (entriesList[_raffleId].length == 0) {
            return;
        }
        // Calculate refund amount based on the tickets bought by msg.sender
        uint256 refundAmount = calculateRefund(_raffleId, msg.sender);

        if (refundAmount <= 0) {
            revert NoRefundAvailable();
        }

        // Mark as claimed
        hasClaimedRefund[_raffleId][msg.sender] = true;

        // Refund the user
        IERC20 usdc = IERC20(usdcContractAddress);

        if (!usdc.transfer(msg.sender, refundAmount)) {
            revert FailedToSendRefund();
        }

        emit Refund(_raffleId, refundAmount, msg.sender);
    }

    function calculateRefund(
        uint256 _raffleId,
        address _player
    ) internal view returns (uint256) {
        uint256 refundAmount = 0;
        uint256 entriesLength = entriesList[_raffleId].length;

        for (uint48 i = 0; i < entriesLength; i++) {
            if (entriesList[_raffleId][i].player == _player) {
                uint48 priceStructureId = entriesList[_raffleId][i]
                    .priceStructureId;
                refundAmount += pricesList[_raffleId][priceStructureId].price;
            }
        }
        return refundAmount;
    }

    function reclaimAssets(uint256 _raffleId) external nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        if (msg.sender != raffle.seller) {
            revert OnlySellerCanReclaim();
        }

        if (block.timestamp <= raffle.deadline) {
            revert RaffleDeadlineNotPassed();
        }

        if (
            rafflesEntryInfo[_raffleId].amountRaised >=
            fundingList[_raffleId].minimumFundsInWei
        ) {
            revert MinimumFundingGoalMet();
        }

        // Transfer asset back to the seller
        if (raffle.assetType == ASSET_TYPE.ERC20) {
            bool transferSuccess = IERC20(raffle.prizeAddress).transfer(
                msg.sender,
                raffle.prizeNumber
            );

            if (!transferSuccess) {
                revert FailedToSendERC20Prize();
            }
        } else if (raffle.assetType == ASSET_TYPE.ERC721) {
            IERC721(raffle.prizeAddress).transferFrom(
                address(this),
                msg.sender,
                raffle.prizeNumber
            );

            if (
                IERC721(raffle.prizeAddress).ownerOf(raffle.prizeNumber) !=
                msg.sender
            ) {
                revert FailedToSendERC721Prize();
            }
        } else if (raffle.assetType == ASSET_TYPE.ETH) {
            (bool sent, ) = payable(msg.sender).call{value: raffle.prizeNumber}(
                ""
            );
            if (!sent) {
                revert FailedToSendEthPrize();
            }
        }

        emit AssetsReclaimed(_raffleId, msg.sender);
    }

    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)
    /// one or more entries will be assigned to the player.
    /// Also it is checked the maximum number of entries per user is not reached
    /// As the method is payable, in msg.value there will be the amount paid by the user
    /// @notice If the operator set requiredNFTs when creating the raffle, only the owners of nft on that collection can make a call to this method. This will be
    /// used for special raffles
    /// @param _raffleId: id of the raffle
    /// @param _id: id of the price structure (package)
    function buyEntry(
        uint256 _raffleId,
        uint48 _id,
        uint256 _usdcAmount
    ) external payable {
        if (tx.origin != msg.sender) revert NoContractsAllowed();
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        if (entryInfo.status != STATUS.ACCEPTED) revert NotInAcceptedStatus();

        // Price checks
        PriceStructure memory priceStruct = pricesList[_raffleId][_id];

        if (_usdcAmount != priceStruct.price) revert IncorrectUSDCAmount();

        // // Ensure the contract is allowed to transfer the specified amount of USDC on behalf of the sender
        IERC20 usdc = IERC20(usdcContractAddress);

        if (usdc.allowance(msg.sender, address(this)) < _usdcAmount)
            revert USDCAllowanceTooLow();

        if (!usdc.transferFrom(msg.sender, address(this), _usdcAmount))
            revert USDCTransferFailed();

        uint48 numEntries = priceStruct.numEntries;

        // save the entries onchain
        uint48 entriesLength = entryInfo.entriesLength;
        EntriesBought memory entryBought = EntriesBought({
            player: msg.sender,
            currentEntriesLength: uint48(entriesLength + numEntries),
            priceStructureId: _id
        });
        entriesList[_raffleId].push(entryBought);

        // update raffle variables
        entryInfo.amountRaised += _usdcAmount;
        entryInfo.entriesLength += numEntries;

        emit EntrySold(_raffleId, msg.sender, entryInfo.entriesLength, _id, "");
    }

    // helper method to get the winner address of a raffle
    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber Generated by chainlink
    /// @return the wallet that won the raffle
    /// @dev Uses a binary search on the sorted array to retreive the winner
    /// but if the winner candidate is blacklisted, loop through the left looking for
    /// a candidate not blacklisted
    function getWinnerAddressFromRandom(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) public view returns (address) {
        uint256 position = findUpperBound(
            entriesList[_raffleId],
            _normalizedRandomNumber
        );

        address candidate = entriesList[_raffleId][position].player;
        // general case
        if (candidate != address(0)) return candidate;
        // special case. The user is blacklisted, so try next on the left until find a non-blacklisted
        else {
            bool ended = false;
            uint256 i = position;
            while (
                ended == false && entriesList[_raffleId][i].player == address(0)
            ) {
                if (i == 0) i = entriesList[_raffleId].length - 1;
                else i = i - 1;
                // we came to the beginning without finding a non blacklisted player
                if (i == position) ended == true;
            }
            require(!ended, "All users blacklisted");
            return entriesList[_raffleId][i].player;
        }
    }

    /// @param array sorted array of EntriesBought. CurrentEntriesLength is the numeric field used to sort
    /// @param element uint256 to find. Goes from 1 to entriesLength
    /// @dev based on openzeppelin code (v4.0), modified to use an array of EntriesBought
    /// Searches a sorted array and returns the first index that contains a value greater or equal to element.
    /// If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).
    /// array is expected to be sorted in ascending order, and to contain no repeated elements.
    /// https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-
    function findUpperBound(
        EntriesBought[] storage array,
        uint256 element
    ) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid].currentEntriesLength > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].currentEntriesLength == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    // The operator can call this method once they receive the event "RandomNumberCreated"
    // triggered by the VRF v1 consumer contract (RandomNumber.sol)
    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber index of the array that contains the winner of the raffle. Generated by chainlink
    /// @notice it is the method that sets the winner and transfers funds and nft
    /// @dev called by Chainlink callback
    function transferPrizesAndFunds(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) internal nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // Only when the raffle has been asked to be closed and the platform

        if (entryInfo.status != STATUS.CLOSING_REQUESTED)
            revert RaffleInWrongStatus();

        raffle.randomNumber = _normalizedRandomNumber;
        raffle.winner = getWinnerAddressFromRandom(
            _raffleId,
            _normalizedRandomNumber
        );
        entryInfo.status = STATUS.ENDED;

        // Distribute the prize based on its type
        if (raffle.assetType == ASSET_TYPE.ERC20) {
            IERC20 erc20Token = IERC20(raffle.prizeAddress);
            if (!erc20Token.transfer(raffle.winner, raffle.prizeNumber))
                revert FailedToSendERC20Prize();
        } else if (raffle.assetType == ASSET_TYPE.ERC721) {
            IERC721 erc721Token = IERC721(raffle.prizeAddress);
            erc721Token.transferFrom(
                address(this),
                raffle.winner,
                raffle.prizeNumber
            );
        } else if (raffle.assetType == ASSET_TYPE.ETH) {
            (bool success, ) = payable(raffle.winner).call{
                value: raffle.prizeNumber
            }("");

            if (!success) revert FailedToSendEthPrize();
        }

        uint256 amountForPlatform = (entryInfo.amountRaised *
            platformFeePercentage) / 10000;
        uint256 amountForSeller = entryInfo.amountRaised - amountForPlatform;

        // transfer the amount to the platform
        (bool feeSent, ) = destinationWallet.call{value: amountForPlatform}("");
        if (!feeSent) revert FailedToSendPlatformFee();

        // Send remaining amount to the seller
        (bool payoutSent, ) = payable(raffle.seller).call{
            value: amountForSeller
        }("");

        if (!payoutSent) revert FailedToSendPayoutToSeller();

        emit FeeTransferredToPlatform(_raffleId, amountForPlatform);
        emit RaffleEnded(
            _raffleId,
            raffle.winner,
            entryInfo.amountRaised,
            _normalizedRandomNumber
        );
    }

    function setWinnerActions(
        uint256 _raffleId
    ) internal returns (EntryInfoStruct memory) {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // RaffleStruct storage raffle = raffles[_raffleId];
        FundingStructure storage funding = fundingList[_raffleId];
        // Check if the raffle is already accepted or is called again because early cashout failed
        if (entryInfo.status != STATUS.ACCEPTED) revert RaffleInWrongStatus();
        if (entryInfo.amountRaised < funding.minimumFundsInWei)
            revert NotEnoughFundsRaised();

        entryInfo.status = STATUS.CLOSING_REQUESTED;

        emit SetWinnerTriggered(_raffleId, entryInfo.amountRaised);
        return entryInfo;
    }

    /// @param _raffleId Id of the raffle
    /// @notice the operator finish the raffle, if the desired funds has been reached
    /// @dev it triggers Chainlink VRF1 consumer, and generates a random number that is normalized and checked that corresponds to a MW player
    function setWinner(uint256 _raffleId) external nonReentrant {
        if (!isOwner()) revert NotTheOwner();

        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);
        // this call trigers the VRF v1 process from Chainlink

        bytes32 requestId = callVRFAndGetRequestId();
        getRandomNumber(_raffleId, raffle.entriesLength, requestId);
    }

    /// @param _newAddress new address of the platform
    /// @dev Change the wallet of the platform. The one that will receive the platform fee when the raffle is closed.
    /// Only the admin can change this
    function setDestinationAddress(address payable _newAddress) external {
        if (!isOwner()) revert NotTheOwner();
        destinationWallet = _newAddress;
    }

    /// @param _raffleId Id of the raffle
    /// @dev The operator can cancel the raffle. The NFT is sent back to the seller
    /// The raised funds are send to the destination wallet. The buyers will
    /// be refunded offchain in the metawin wallet
    //TODO: add type of refund (ETH, ERC20, ERC721)
    function cancelRaffle(uint256 _raffleId) external nonReentrant {
        if (!isOwner()) revert NotTheOwner();

        RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // Dont cancel twice, or cancel an already ended raffle
        require(
            entryInfo.status != STATUS.ENDED &&
                entryInfo.status != STATUS.CANCELLED &&
                entryInfo.status != STATUS.CLOSING_REQUESTED &&
                entryInfo.status != STATUS.CANCEL_REQUESTED,
            "Wrong status"
        );

        // only if the raffle is in accepted status the NFT is staked and could have entries sold
        if (entryInfo.status == STATUS.ACCEPTED) {
            if (raffle.assetType == ASSET_TYPE.ERC20) {
                bool transferSuccess = IERC20(raffle.prizeAddress).transfer(
                    raffle.seller,
                    raffle.prizeNumber
                );

                if (!transferSuccess) {
                    revert FailedToSendERC20Prize();
                }
            } else if (raffle.assetType == ASSET_TYPE.ERC721) {
                IERC721(raffle.prizeAddress).transferFrom(
                    address(this),
                    raffle.seller,
                    raffle.prizeNumber
                );
                if (
                    IERC721(raffle.prizeAddress).ownerOf(raffle.prizeNumber) !=
                    msg.sender
                ) {
                    revert FailedToSendERC721Prize();
                }
            } else if (raffle.assetType == ASSET_TYPE.ETH) {
                (bool sent, ) = payable(raffle.seller).call{
                    value: raffle.prizeNumber
                }("");
                if (!sent) {
                    revert FailedToSendEthPrize();
                }
            }
        }

        entryInfo.status = STATUS.CANCEL_REQUESTED;
        raffle.cancellingDate = uint48(block.timestamp);

        emit RaffleCancelled(_raffleId, entryInfo.amountRaised);
    }

    /// @param _raffleId Id of the raffle
    /// @dev after 30 days after cancelling passes, the operator can transfer to
    /// destinationWallet the remaining funds
    function transferRemainingFunds(uint256 _raffleId) external nonReentrant {
        if (!isOwner()) revert NotTheOwner();

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        if (
            !(entryInfo.status == STATUS.CANCEL_REQUESTED ||
                entryInfo.status == STATUS.CANCELLED)
        ) revert WrongStatus();

        entryInfo.status = STATUS.CANCELLED;

        (bool sent, ) = destinationWallet.call{value: entryInfo.amountRaised}(
            ""
        );
        if (!sent) revert FailSendEthToOW();

        emit RemainingFundsTransferred(_raffleId, entryInfo.amountRaised);

        entryInfo.amountRaised = 0;
    }

    /// @dev for different reasons player entries should be void
    /// this has a cost in gas, but this makes cheaper in gas the callback from chainlink
    /// This method has to be called for every raffle of the blacklisted player
    /// @param _raffleId Id of the raffle
    /// @param entriesToCancel array that contains the index of the entries to cancel. 0 based
    /// @param _player player who owns the entry to be voided
    function cancelEntry(
        uint256 _raffleId,
        uint256[] calldata entriesToCancel,
        address _player
    ) external {
        if (!isOwner()) revert NotTheOwner();

        uint256 totalEntriesBoughtCancelled = 0;
        for (uint256 i = 0; i < entriesToCancel.length; i++) {
            EntriesBought storage entry = entriesList[_raffleId][
                entriesToCancel[i] + 1
            ];

            if (entry.player != _player) revert EntryDoesNotBelongToPlayer();

            entry.player = address(0);

            uint256 previousTotalEntriesLength;
            if (entriesToCancel[i] == 0) previousTotalEntriesLength = 0;
            else
                previousTotalEntriesLength = entriesList[_raffleId][
                    entriesToCancel[i] /* - 1*/
                ].currentEntriesLength;
            totalEntriesBoughtCancelled +=
                entry.currentEntriesLength -
                previousTotalEntriesLength;
        }
        emit EntryCancelled(_raffleId, totalEntriesBoughtCancelled, _player);
    }

    function getRafflesEntryInfo(
        uint256 _raffleId
    ) public view returns (EntryInfoStruct memory) {
        return rafflesEntryInfo[_raffleId];
    }

    function setUSDCTokenAddress(address _usdcContractAddress) external {
        if (!isOwner()) revert NotTheOwner();

        usdcContractAddress = _usdcContractAddress;
    }

    /// @dev Handles a received CCIP message, processes it, and acknowledges its receipt.
    /// This internal function is called upon the receipt of a new message via CCIP from an allowlisted source chain and sender.
    /// @param message The CCIP message received
    function _ccipReceive(
        Client.Any2EVMMessage memory message // onlyAllowlisted(
        //     message.sourceChainSelector,
    ) internal override //     abi.decode(message.sender, (address))
    // )
    {
        uint8 messageType = abi.decode(message.data, (uint8));

        if (messageType == uint8(MESSAGE_TYPE.CREATE_RAFFLE_FROM_SIDECHAIN)) {
            _createRaffleFromSidechain(message);
        }

        if (messageType == uint8(MESSAGE_TYPE.BUY_ENTRY)) {
            _buyEntryFromSidechain(message);
        }
    }

    function _createRaffleFromSidechain(
        Client.Any2EVMMessage memory message
    ) internal {
        //create raffle from side chain with prize on side chain and ack back to side chain
        // bytes32 messageIdSourceChain = message.messageId;
        bytes32 testMessageIdSourceChain = 0x894cccafe7a46ef3ce0297f766eb759c3aa439ab77472626d2ba98088308cee4;

        (
            uint8 messageTypeReceived,
            uint128 minimumFundsInWei,
            PriceStructure[] memory prices,
            uint256 deadline,
            address seller,
            SChains[] memory _chainSelectors
        ) = abi.decode(
                message.data,
                (uint8, uint128, PriceStructure[], uint256, address, SChains[])
            );

        uint256 raffleId = _createRaffle(
            address(0),
            0,
            minimumFundsInWei,
            prices,
            ASSET_TYPE.CCIP,
            deadline,
            seller,
            _chainSelectors
        );

        address _receiver = abi.decode(message.sender, (address));

        RaffleCreationAckParams
            memory raffleCreationAckParams = RaffleCreationAckParams({
                receiver: _receiver,
                messageType: MESSAGE_TYPE.CREATE_RAFFLE_ACK,
                messageIdSourceChain: testMessageIdSourceChain,
                raffleId: raffleId,
                message: message,
                deadline: raffles[raffleId].deadline
            });

        _sendAckRaffleCreation(raffleCreationAckParams);

        emit RaffleCreatedFromSidechain(
            raffleId,
            minimumFundsInWei,
            prices,
            deadline,
            seller,
            testMessageIdSourceChain
        );
    }

    function _sendAckRaffleCreation(
        RaffleCreationAckParams memory params
    ) internal {
        Client.EVM2AnyMessage memory any2EvmMessage = Client.EVM2AnyMessage({
            receiver: abi.encode(params.receiver),
            data: abi.encode(
                params.messageType,
                params.messageIdSourceChain,
                params.raffleId,
                params.deadline
            ),
            tokenAmounts: new Client.EVMTokenAmount[](0),
            extraArgs: Client._argsToBytes(
                Client.EVMExtraArgsV1({gasLimit: 300_000})
            ),
            feeToken: link
        });

        uint256 feeCCIP = IRouterClient(router).getFee(
            params.message.sourceChainSelector,
            any2EvmMessage
        );

        LinkTokenInterface(link).approve(router, feeCCIP);

        bytes32 messageId = IRouterClient(router).ccipSend(
            params.message.sourceChainSelector,
            any2EvmMessage
        );

        emit AckRaffleCreationFromSidechain(
            params.raffleId,
            params.receiver,
            params.messageIdSourceChain,
            messageId
        );
    }

    function _buyEntryFromSidechain(
        Client.Any2EVMMessage memory message
    ) internal {
        bytes32 messageIdSourceChain = message.messageId;

        (
            uint8 messageTypeReceived,
            uint256 raffleId,
            address buyer,
            uint256 priceStructureId
        ) = abi.decode(message.data, (uint8, uint256, address, uint256));

        _buyEntryCCIP(raffleId, priceStructureId, buyer, messageIdSourceChain);
    }

    function _buyEntryCCIP(
        uint256 _raffleId,
        uint256 _priceStructureId,
        address _buyer,
        bytes32 _messageIdSourceChain
    ) internal {
        PriceStructure memory priceStruct = pricesList[_raffleId][
            _priceStructureId
        ];

        uint48 numEntries = priceStruct.numEntries;
        uint256 usdcAmount = priceStruct.price;

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        uint48 entriesLength = entryInfo.entriesLength;

        EntriesBought memory entryBought = EntriesBought({
            player: _buyer,
            currentEntriesLength: uint48(entriesLength + numEntries),
            priceStructureId: uint48(_priceStructureId)
        });
        entriesList[_raffleId].push(entryBought);

        // update raffle variables
        entryInfo.amountRaised += usdcAmount;
        entryInfo.entriesLength += numEntries;

        //TODO: say that its coming from sidechain and what sidechain
        emit EntrySold(
            _raffleId,
            _buyer,
            entriesLength,
            _priceStructureId,
            _messageIdSourceChain
        );
    }
}
