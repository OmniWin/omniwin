// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBase.sol";
// import "@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol";
import {VRFConsumerBaseV2} from "@chainlink/contracts/src/v0.8/vrf/VRFConsumerBaseV2.sol";
import {VRFCoordinatorV2Interface} from "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";

import "@openzeppelin/contracts/utils/math/Math.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {IRouterClient} from "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol";
import {Client} from "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol";
import {LinkTokenInterface} from "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol";
import {CCIPReceiver} from "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol";

import "hardhat/console.sol";

contract Omniwin is ReentrancyGuard, VRFConsumerBaseV2, CCIPReceiver {
    uint256 maxDeadlineDuration = 30 days;
    uint48 platformFeePercentage = 600;

    address public usdcContractAddress;
    uint64 public mainChainSelector = 1; //TODO: set the main chain selector

    uint256 ccipMessageFee = 500000; //50c USD

    //CCIP
    address immutable link;
    address immutable router;

    //Chainlink VRF v1
    bytes32 internal immutable keyHash; // chainlink
    uint256 internal immutable fee; // fee paid in LINK to chainlink. 0.1 in Rinkeby, 2 in mainnet

    enum STATUS {
        ACCEPTED, // the seller stakes the nft for the raffle
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // setting the winner is requested
        ENDED, // the raffle is finished, and NFT and funds are being distributed
        FAILED, // the raffle is finished, and the funds are refunded
        DISTRIBUTING_PRIZE // the raffle is finished, and the prize is being distributed
    }

    enum ASSET_TYPE {
        ERC20,
        ERC721,
        ETH,
        CCIP
    }
    enum MESSAGE_TYPE {
        CREATE_RAFFLE_FROM_SIDECHAIN,
        BUY_ENTRY,
        CREATE_RAFFLE_FROM_MAINCHAIN,
        PRIZE_DISTRIBUTION,
        FAILED_RAFFLE,
        IS_REFUNDABLE,
        IS_RAFFLE_CREATED
    }

    // event sent when the random number is generated by the VRF
    event RandomNumberCreated(
        bytes32 indexed raffleId,
        uint256 randomNumber,
        uint256 normalizedRandomNumber
    );

    event CreateRaffle(
        bytes32 indexed raffleId,
        address indexed nftAddress,
        uint256 indexed nftId,
        ASSET_TYPE assetType,
        address seller,
        uint128 minimumFundsInWei,
        uint256 deadline
    );

    event CreateRaffleToSidechain(
        bytes32 indexed raffleId,
        address indexed receiver,
        uint64 indexed chainSelector,
        uint256 gasLimit
    );

    event RaffleEnded(
        bytes32 indexed raffleId,
        address indexed winner,
        uint256 amountRaised,
        uint256 randomNumber
    );

    event EntrySold(
        bytes32 indexed raffleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId,
        bytes32 messageId
    );

    event EntrySoldCCIP(
        bytes32 indexed raffleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId,
        bytes32 messageId
    );

    event FreeEntry(
        bytes32 indexed raffleId,
        address[] buyer,
        uint256 amount,
        uint256 currentSize
    );

    event FeeTransferredToPlatform(
        bytes32 indexed raffleId,
        uint256 amountTransferred
    );
    event RaffleEnabledFromSidechain(
        bytes32 raffleId,
        address sender,
        bytes32 messageId
    );

    event Refund(
        bytes32 indexed raffleId,
        uint256 amountInWeis,
        address indexed player
    );

    event SetWinnerTriggered(bytes32 indexed raffleId, uint256 amountRaised);

    event AssetsReclaimed(bytes32 indexed raffleId, address indexed seller);

    event IsRefundableCCIP(
        bytes32 indexed raffleId,
        bool isRefundable,
        bytes32 messageIdSourceChain,
        bytes32 messageId
    );

    event PrizeDistributionToSidechain(
        bytes32 raffleId,
        address receiver,
        address winner,
        address seller,
        bytes32 messageId
    );

    event FailedRaffleToSidechain(
        bytes32 raffleId,
        address receiver,
        bytes32 messageId
    );

    event RaffleCreatedFromSidechain(
        bytes32 raffleId,
        address receiver,
        bytes32 messageIdSourceChain
    );

    event PrizeAwarded(bytes32 indexed raffleId, address indexed winner);

    event IsRaffleCreatedCCIP(
        bytes32 raffleId,
        bool isRaffleCreated,
        bytes32 messageIdSourceChain
    );

    event CashClaimed(bytes32 indexed raffleId, uint256 amount, address seller);

    struct RaffleCreationAckParams {
        address receiver;
        MESSAGE_TYPE messageType;
        bytes32 messageIdSourceChain;
        bytes32 raffleId;
        Client.Any2EVMMessage message;
        uint256 deadline;
    }

    struct RandomResult {
        uint256 randomNumber; // random number generated by chainlink.
        uint256 nomalizedRandomNumber; // random number % entriesLength + 1. So between 1 and entries.length
    }

    struct RaffleInfo {
        bytes32 id; // raffleId
        uint256 size; // length of the entries array of that raffle
    }

    /* every raffle has an array of price structure (max size = 5) with the different 
    prices for the different entries bought. The price for 1 entry is different than 
    for 5 entries where there is a discount*/
    struct PriceStructure {
        uint48 numEntries;
        uint256 price;
    }

    // Every raffle has a funding structure.
    struct FundingStructure {
        uint128 minimumFundsInWei;
        bool platformFeeCollected;
        bool prizeClaimed;
        bool cashClaimed;
    }

    // In order to calculate the winner, in this struct is saved for each bought the data
    struct EntriesBought {
        uint48 currentEntriesLength; // current amount of entries bought in the raffle
        address player; // wallet address of the player
        uint48 priceStructureId; // id of the price structure
        address sender;
        bytes32 messageId;
    }

    // Main raffle data struct
    struct RaffleStruct {
        uint256 prizeNumber; // number (can be a percentage, an id, an amount, etc. depending on the competition)
        address prizeAddress; // address of the prize
        address winner; // address of thed winner of the raffle. Address(0) if no winner yet
        address seller; // address of the seller of the NFT
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
        ASSET_TYPE assetType; // type of the asset. Can be ERC20, ERC721, ETH
        uint256 deadline; // deadline to set a winner
    }

    struct EntryInfoStruct {
        STATUS status; // status of the raffle.
        uint48 entriesLength; // to easy frontend, the length of the entries array is saved here
        uint256 amountRaised; // funds raised so far in wei
    }

    struct SChains {
        address ccnsReceiverAddress;
        uint256 gasLimit;
        uint64 chainSelector;
    }

    error USDCAallowanceTooLow();
    error EntryNotAllowed(string errorType);
    error CreateRaffleError();
    error PriceStructureError();
    error DeadlineExceedsMaximum();
    error CreateRaffleFromSidechainError(string errorType);
    error InsufficientLinkBalance();
    error DirectCCIPRafflesNotAllowed();
    error NotTheSeller();
    error NotTheOwner();
    error NotTheNFTOwner();
    error ContractNotApproved();
    error AllowanceError();
    error TransferFailed();
    error ETHPrizeAmountMismatch();
    error RaffleDeadlineNotPassed();
    error MinimumFundingGoalMet();
    error AlreadyClaimedRefund();
    error NoEntriesFound();
    error InvalidRaffle();
    error NoRefundAvailable();
    error FailedToSendRefund();
    error OnlySellerCanReclaim();
    error FailedToSendERC20Prize();
    error FailedToSendERC721Prize();
    error FailedToSendEthPrize();
    error FailedToStoreEthPrize();
    error NoContractsAllowed();
    error NotInAcceptedStatus();
    error IncorrectUSDCAmount();
    error USDCAllowanceTooLow();
    error USDCTransferFailed();
    error RaffleInWrongStatus();
    error FailedToSendPlatformFee();
    error FailedToSendPlatformFeeNotEnough();
    error FailedToSendPayoutToSeller();
    error NotEnoughFundsRaised();
    error NoFundsRaised();
    error WrongStatus();
    error FailSendEthToOW();
    error EntryDoesNotBelongToPlayer();
    error NumEntriesIsZero();
    error DestinationChainNotAllowlisted();
    error SourceChainNotAllowlisted(); // Used when the source chain has not been allowlisted by the contract owner.
    error SenderNotAllowlisted(); // Used when the sender has not been allowlisted by the contract owner.
    error WinnerNotElected();
    error AlreadyClaimed();
    error NotTheWinner();
    error FailedToSendCashForSeller();

    mapping(bytes32 => RandomResult) public requests;
    // map the requestId created by chainlink with the raffle info passed as param when calling getRandomNumber()
    mapping(uint256 => RaffleInfo) public chainlinkRaffleInfo;

    mapping(bytes32 => PriceStructure[]) public pricesList;
    mapping(bytes32 => FundingStructure) public fundingList;
    mapping(bytes32 => EntriesBought[]) public entriesList;
    mapping(bytes32 => mapping(bytes32 => bool)) public ticketsBoughtCCIP;

    // A mapping to track the amount raised from each chain
    struct ChainAction {
        bool hasActivity; // has bought a ticket or holds the prize
        uint256 amount;
    }

    mapping(bytes32 => mapping(address => ChainAction))
        private raffleChainActions;

    //CCIP
    struct ChainInfo {
        uint64 chainSelector;
        address receiverAddress;
        uint32 gasLimit;
    }

    ChainInfo[] public supportedChains;

    // Mapping to keep track of allowlisted destination chains.
    mapping(uint64 => bool) public allowlistedDestinationChains;

    // Mapping to keep track of allowlisted source chains.
    mapping(uint64 => bool) public allowlistedSourceChains;

    // Mapping to keep track of allowlisted senders.
    mapping(address => bool) public allowlistedSenders;

    // The main structure is an array of raffles
    // RaffleStruct[] public raffles;
    mapping(bytes32 => RaffleStruct) public raffles;

    // The main structure is an array of raffles
    // EntryInfoStruct[] public rafflesEntryInfo;
    mapping(bytes32 => EntryInfoStruct) public rafflesEntryInfo;

    struct Claimed {
        bool refund;
        bool prize;
        bool cash;
    }
    mapping(bytes32 => mapping(address => Claimed)) public hasClaimedRefund;

    // address of the wallet controlled by the platform that will receive the platform fee
    address payable public destinationWallet =
        payable(0x15E30D5c9Ed5d134C8FCD06120D5b6AB7e093426);

    address public owner;
    VRFCoordinatorV2Interface immutable COORDINATOR;
    uint64 immutable subscriptionId;

    constructor(
        address _vrfCoordinator,
        address _linkToken,
        bytes32 _keyHash,
        bool _mainetFee,
        address _router,
        uint64 _subscriptionId
    ) VRFConsumerBaseV2(_vrfCoordinator) CCIPReceiver(_router) {
        COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);

        owner = msg.sender;

        link = _linkToken;
        router = _router;
        subscriptionId = _subscriptionId;

        unchecked {
            uint256 _fee;
            keyHash = _keyHash;
            if (_mainetFee == true)
                _fee = 2 * 10 ** 18; // in mainnet, the fee must be 2 LINK
            else _fee = 0.1 * 10 ** 18; // 0.1 LINK In Rinkeby and Goerli
            fee = _fee;
        }
    }

    /// @dev Modifier that checks if the chain with the given destinationChainSelector is allowlisted.
    /// @param _destinationChainSelector The selector of the destination chain.
    modifier onlyAllowlistedDestinationChain(uint64 _destinationChainSelector) {
        if (!allowlistedDestinationChains[_destinationChainSelector])
            revert DestinationChainNotAllowlisted();
        _;
    }

    /// @dev Modifier that checks if the chain with the given sourceChainSelector is allowlisted and if the sender is allowlisted.
    /// @param _sourceChainSelector The selector of the destination chain.
    /// @param _sender The address of the sender.
    modifier onlyAllowlisted(uint64 _sourceChainSelector, address _sender) {
        if (!allowlistedSourceChains[_sourceChainSelector])
            revert SourceChainNotAllowlisted();
        if (!allowlistedSenders[_sender]) revert SenderNotAllowlisted();
        _;
    }

    /// @dev Updates the allowlist status of a destination chain for transactions.
    function allowlistDestinationChain(
        uint64 _destinationChainSelector,
        bool allowed
    ) external {
        if (!isOwner()) revert NotTheOwner();
        allowlistedDestinationChains[_destinationChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a source chain for transactions.
    function allowlistSourceChain(
        uint64 _sourceChainSelector,
        bool allowed
    ) external {
        if (!isOwner()) revert NotTheOwner();
        allowlistedSourceChains[_sourceChainSelector] = allowed;
    }

    /// @dev Updates the allowlist status of a sender for transactions.
    function allowlistSender(address _sender, bool allowed) external {
        if (!isOwner()) revert NotTheOwner();
        allowlistedSenders[_sender] = allowed;
    }

    function setCcipMessageFee(uint256 _fee) external {
        if (!isOwner()) revert NotTheOwner();
        ccipMessageFee = _fee;
    }

    function isOwner() internal view returns (bool) {
        return msg.sender == owner;
    }

    //Must be called after setWinner is called
    function sendPrizeDistributionMessages(
        bytes32 _raffleId,
        SChains[] calldata _supportedChains
    ) external {
        if (!isOwner()) revert NotTheOwner();

        bool shouldTransferFee = raffleChainActions[_raffleId][address(this)]
            .hasActivity &&
            raffleChainActions[_raffleId][address(this)].amount > 0 &&
            !fundingList[_raffleId].platformFeeCollected;

        if (shouldTransferFee) {
            transferFeeToPlatform(_raffleId);
            fundingList[_raffleId].platformFeeCollected = true;
        }

        rafflesEntryInfo[_raffleId].status = STATUS.DISTRIBUTING_PRIZE;

        for (uint256 i = 0; i < _supportedChains.length; ++i) {
            if (_supportedChains[i].chainSelector != mainChainSelector) {
                processChain(_raffleId, _supportedChains[i]);
            }
        }
    }

    function processChain(bytes32 _raffleId, SChains memory chain) internal {
        address receiver = chain.ccnsReceiverAddress;
        ChainAction storage chainAction = raffleChainActions[_raffleId][
            receiver
        ];

        if (chainAction.hasActivity) {
            uint256 amountForPlatform = (chainAction.amount *
                platformFeePercentage) / 10000;
            uint256 amountToSend = chainAction.amount - amountForPlatform;

            bytes memory data = abi.encode(
                MESSAGE_TYPE.PRIZE_DISTRIBUTION,
                _raffleId,
                raffles[_raffleId].winner,
                raffles[_raffleId].seller,
                amountToSend
            );

            bytes32 messageId = sendMessage(
                chain.chainSelector,
                receiver,
                data,
                chain.gasLimit
            );

            emit PrizeDistributionToSidechain(
                _raffleId,
                receiver,
                raffles[_raffleId].winner,
                raffles[_raffleId].seller,
                messageId
            );
        }
    }

    //Must be called after setWinner is called
    function sendPrizeDistributionMessagesWithStatusFail(
        bytes32 _raffleId,
        SChains[] calldata _supportedChains
    ) external nonReentrant {
        if (!isOwner()) revert NotTheOwner();

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        if (block.timestamp <= raffles[_raffleId].deadline) {
            revert RaffleDeadlineNotPassed();
        }

        if (
            entryInfo.amountRaised >= fundingList[_raffleId].minimumFundsInWei
        ) {
            revert MinimumFundingGoalMet();
        }

        for (uint256 i = 0; i < _supportedChains.length; ++i) {
            if (_supportedChains[i].chainSelector != mainChainSelector) {
                address receiver = _supportedChains[i].ccnsReceiverAddress;
                ChainAction storage chainAction = raffleChainActions[_raffleId][
                    receiver
                ];

                if (chainAction.hasActivity) {
                    uint64 chainSelector = _supportedChains[i].chainSelector;
                    MESSAGE_TYPE messageType = MESSAGE_TYPE.FAILED_RAFFLE;
                    bytes memory data = abi.encode(messageType, _raffleId);

                    bytes32 messageId = sendMessage(
                        chainSelector,
                        receiver,
                        data,
                        _supportedChains[i].gasLimit
                    );

                    emit FailedRaffleToSidechain(
                        _raffleId,
                        receiver,
                        messageId
                    );
                }
            }
        }

        rafflesEntryInfo[_raffleId].status = STATUS.FAILED;
    }

    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {
        uint256 randomness = _randomWords[0];
        // randomness is the actual random number. Now extract from the aux map the original param id of the call
        RaffleInfo memory raffleInfo = chainlinkRaffleInfo[_requestId];
        // save the random number on the map with the original id as key
        uint256 normalizedRandomNumber = (randomness % raffleInfo.size) + 1;

        RandomResult memory result = RandomResult({
            randomNumber: randomness,
            nomalizedRandomNumber: normalizedRandomNumber
        });

        requests[raffleInfo.id] = result;

        // send the event with the original id and the random number
        emit RandomNumberCreated(
            raffleInfo.id,
            randomness,
            normalizedRandomNumber
        );

        selectWinner(raffleInfo.id, normalizedRandomNumber);
    }

    function selectWinner(
        bytes32 _raffleId,
        uint256 _normalizedRandomNumber
    ) internal {
        RaffleStruct storage raffle = raffles[_raffleId];
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        raffle.randomNumber = _normalizedRandomNumber;
        raffle.winner = getWinnerAddressFromRandom(
            _raffleId,
            _normalizedRandomNumber
        );

        entryInfo.status = STATUS.ENDED;

        emit RaffleEnded(
            _raffleId,
            raffle.winner,
            entryInfo.amountRaised,
            _normalizedRandomNumber
        );
    }

    function transferFeeToPlatform(bytes32 _raffleId) internal nonReentrant {
        uint256 amountRaised = raffleChainActions[_raffleId][address(this)]
            .amount;

        uint256 amountForPlatform = (amountRaised * platformFeePercentage) /
            10000;

        IERC20 usdc = IERC20(usdcContractAddress);
        uint256 balance = usdc.balanceOf(address(this));

        if (balance < amountForPlatform) {
            revert FailedToSendPlatformFeeNotEnough();
        }

        bool feeSent = usdc.transfer(destinationWallet, amountForPlatform);

        if (!feeSent) {
            revert FailedToSendPlatformFee();
        }

        emit FeeTransferredToPlatform(_raffleId, amountForPlatform);
    }

    function _createRaffle(
        address _prizeAddress,
        uint256 _prizeNumber,
        uint128 _minimumFundsInWei,
        PriceStructure[] memory _prices,
        ASSET_TYPE _assetType,
        uint256 _deadlineDuration,
        address _seller,
        bytes32 _raffleId
    ) internal returns (bytes32) {
        if (_deadlineDuration > maxDeadlineDuration) {
            revert DeadlineExceedsMaximum();
        }

        if (_prices.length == 0 || _prices.length > 6)
            revert PriceStructureError();

        bytes32 raffleId = _raffleId;

        if (_assetType != ASSET_TYPE.CCIP) {
            // Handle the transfer and ownership validation based on asset type
            handleAssetTransferAndValidation(
                _seller,
                address(this),
                _prizeAddress,
                _prizeNumber,
                _assetType
            );

            // Generate a unique key
            raffleId = keccak256(abi.encodePacked(msg.sender, block.timestamp));
        }

        if (raffles[raffleId].deadline != 0) {
            revert CreateRaffleError();
        }

        for (uint256 i = 0; i < _prices.length; ++i) {
            if (_prices[i].numEntries == 0) revert NumEntriesIsZero();

            pricesList[raffleId].push(_prices[i]);
        }

        raffles[raffleId] = RaffleStruct({
            prizeNumber: _prizeNumber,
            prizeAddress: _prizeAddress,
            winner: address(0),
            seller: _seller,
            randomNumber: 0,
            assetType: _assetType,
            deadline: block.timestamp + _deadlineDuration
        });

        EntryInfoStruct memory entryInfo = EntryInfoStruct({
            status: STATUS.ACCEPTED,
            amountRaised: 0,
            entriesLength: 0
        });

        rafflesEntryInfo[raffleId] = entryInfo;

        fundingList[raffleId] = FundingStructure({
            minimumFundsInWei: _minimumFundsInWei,
            platformFeeCollected: false,
            prizeClaimed: false,
            cashClaimed: false
        });

        emit CreateRaffle(
            raffleId,
            _prizeAddress,
            _prizeNumber,
            _assetType,
            _seller,
            _minimumFundsInWei,
            block.timestamp + _deadlineDuration
        );

        return raffleId;
    }

    function createRaffle(
        address _prizeAddress,
        uint256 _prizeNumber,
        uint128 _minimumFundsInWei,
        PriceStructure[] calldata _prices,
        ASSET_TYPE _assetType,
        uint256 _deadlineDuration
    ) external payable returns (bytes32) {
        if (_assetType == ASSET_TYPE.CCIP) {
            revert DirectCCIPRafflesNotAllowed();
        }

        return
            _createRaffle(
                _prizeAddress,
                _prizeNumber,
                _minimumFundsInWei,
                _prices,
                _assetType,
                _deadlineDuration,
                msg.sender,
                bytes32(0)
            );
    }

    function enableCreateRaffleOnSidechain(
        bytes32 _raffleId,
        SChains calldata _chainSelector
    ) external {
        RaffleStruct storage raffle = raffles[_raffleId];
        if (raffle.seller != msg.sender) {
            revert NotTheSeller();
        }

        if (rafflesEntryInfo[_raffleId].status != STATUS.ACCEPTED) {
            revert NotInAcceptedStatus();
        }

        // Check if each chainSelector is allowlisted
        if (!allowlistedDestinationChains[_chainSelector.chainSelector]) {
            revert DestinationChainNotAllowlisted();
        }

        IERC20 usdc = IERC20(usdcContractAddress);
        uint256 allowance = usdc.allowance(msg.sender, address(this));
        if (allowance < ccipMessageFee) {
            revert USDCAallowanceTooLow();
        }

        if (!usdc.transferFrom(msg.sender, destinationWallet, ccipMessageFee)) {
            revert FailedToSendPlatformFee();
        }

        SChains memory currentChain = _chainSelector;
        MESSAGE_TYPE messageType = MESSAGE_TYPE.CREATE_RAFFLE_FROM_MAINCHAIN;

        bytes memory data = abi.encode(
            messageType,
            pricesList[_raffleId],
            raffle.deadline,
            _raffleId
        );
        sendMessage(
            currentChain.chainSelector,
            currentChain.ccnsReceiverAddress,
            data,
            currentChain.gasLimit
        );

        emit CreateRaffleToSidechain(
            _raffleId,
            currentChain.ccnsReceiverAddress,
            currentChain.chainSelector,
            currentChain.gasLimit
        );
    }

    function setFee(uint48 _fee) external {
        if (!isOwner()) {
            revert NotTheOwner();
        }

        platformFeePercentage = _fee;
    }

    //Winner claim amount raised
    function claimCash(bytes32 _raffleId) external nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];

        if (raffle.seller != msg.sender) {
            revert NotTheSeller();
        }

        if (raffle.winner == address(0)) {
            revert WinnerNotElected();
        }

        EntryInfoStruct memory entryInfo = rafflesEntryInfo[_raffleId];
        if (entryInfo.status == STATUS.FAILED) {
            revert WrongStatus();
        }

        if (fundingList[_raffleId].cashClaimed) {
            revert AlreadyClaimed();
        }

        //amount raised on this chain
        uint256 amountRaised = raffleChainActions[_raffleId][address(this)]
            .amount;

        if (amountRaised == 0) {
            revert NoFundsRaised();
        }

        uint256 amountForPlatform = (amountRaised * platformFeePercentage) /
            10000;

        uint256 amountForSeller = amountRaised - amountForPlatform;

        if (amountRaised == 0) {
            revert NoFundsRaised();
        }

        IERC20 usdc = IERC20(usdcContractAddress);
        //check contract balance of usdc
        if (!usdc.transfer(msg.sender, amountForSeller)) {
            revert FailedToSendCashForSeller();
        }

        fundingList[_raffleId].cashClaimed = true;

        //emit claimed cash
        emit CashClaimed(_raffleId, amountForSeller, msg.sender);
    }

    function claimPrize(bytes32 _raffleId) external nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];

        if (raffle.winner != msg.sender) {
            revert NotTheWinner();
        }

        if (fundingList[_raffleId].prizeClaimed) {
            revert AlreadyClaimed();
        }

        if (raffle.deadline == 0) {
            revert InvalidRaffle();
        }

        //transfer prize to the winner
        transferAsset(address(this), msg.sender, _raffleId);

        fundingList[_raffleId].prizeClaimed = true;

        emit PrizeAwarded(_raffleId, raffle.winner);
    }

    function claimRefundBoughtTickets(bytes32 _raffleId) external nonReentrant {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        if (block.timestamp <= raffles[_raffleId].deadline) {
            revert RaffleDeadlineNotPassed();
        }

        if (
            entryInfo.amountRaised >= fundingList[_raffleId].minimumFundsInWei
        ) {
            revert MinimumFundingGoalMet();
        }

        if (hasClaimedRefund[_raffleId][msg.sender].refund) {
            revert AlreadyClaimedRefund();
        }

        // Ensure there's a check here to prevent out-of-bounds access
        if (entriesList[_raffleId].length == 0) {
            revert NoEntriesFound();
        }
        // Calculate refund amount based on the tickets bought by msg.sender
        uint256 refundAmount = calculateRefund(_raffleId, msg.sender);

        if (refundAmount <= 0) {
            revert NoRefundAvailable();
        }

        // Refund the user
        IERC20 usdc = IERC20(usdcContractAddress);

        if (!usdc.transfer(msg.sender, refundAmount)) {
            revert FailedToSendRefund();
        }

        hasClaimedRefund[_raffleId][msg.sender].refund = true;

        emit Refund(_raffleId, refundAmount, msg.sender);
    }

    function calculateRefund(
        bytes32 _raffleId,
        address _player
    ) internal view returns (uint256) {
        uint256 refundAmount = 0;
        uint256 entriesLength = entriesList[_raffleId].length;

        for (uint48 i = 0; i < entriesLength; i++) {
            if (
                entriesList[_raffleId][i].player == _player &&
                entriesList[_raffleId][i].sender == address(this)
            ) {
                uint48 priceStructureId = entriesList[_raffleId][i]
                    .priceStructureId;
                refundAmount += pricesList[_raffleId][priceStructureId].price;
            }
        }
        return refundAmount;
    }

    function reclaimAsset(bytes32 _raffleId) external nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        if (msg.sender != raffle.seller) {
            revert OnlySellerCanReclaim();
        }

        if (block.timestamp <= raffle.deadline) {
            revert RaffleDeadlineNotPassed();
        }

        if (
            rafflesEntryInfo[_raffleId].amountRaised >=
            fundingList[_raffleId].minimumFundsInWei
        ) {
            revert MinimumFundingGoalMet();
        }

        // Transfer asset back to the seller
        transferAsset(address(this), msg.sender, _raffleId);

        emit AssetsReclaimed(_raffleId, msg.sender);
    }

    function handleAssetTransferAndValidation(
        address sender,
        address recipient,
        address _prizeAddress,
        uint256 _prizeNumber,
        ASSET_TYPE _assetType
    ) internal {
        if (_assetType == ASSET_TYPE.ERC721) {
            IERC721 prizeToken = IERC721(_prizeAddress);
            if (prizeToken.ownerOf(_prizeNumber) != sender) {
                revert NotTheNFTOwner();
            }

            if (
                !(prizeToken.isApprovedForAll(sender, recipient) ||
                    prizeToken.getApproved(_prizeNumber) == recipient)
            ) {
                revert ContractNotApproved();
            }

            prizeToken.transferFrom(sender, recipient, _prizeNumber);
        } else if (_assetType == ASSET_TYPE.ERC20) {
            IERC20 prizeToken = IERC20(_prizeAddress);
            if (prizeToken.allowance(sender, recipient) < _prizeNumber) {
                revert AllowanceError();
            }

            if (!prizeToken.transferFrom(sender, recipient, _prizeNumber)) {
                revert TransferFailed();
            }
        } else if (_assetType == ASSET_TYPE.ETH) {
            if (msg.value != _prizeNumber) {
                revert ETHPrizeAmountMismatch();
            }
        }
    }

    function transferAsset(
        address from,
        address to,
        bytes32 raffleId
    ) internal {
        RaffleStruct storage raffle = raffles[raffleId];

        if (raffle.assetType == ASSET_TYPE.ERC721) {
            IERC721(raffle.prizeAddress).transferFrom(
                from,
                to,
                raffle.prizeNumber
            );
        } else if (raffle.assetType == ASSET_TYPE.ERC20) {
            require(
                IERC20(raffle.prizeAddress).transfer(to, raffle.prizeNumber),
                "Transfer failed"
            );
        } else if (raffle.assetType == ASSET_TYPE.ETH) {
            (bool sent, ) = to.call{value: raffle.prizeNumber}("");

            if (!sent) {
                revert FailedToSendEthPrize();
            }
        }
    }

    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)
    /// one or more entries will be assigned to the player.
    /// @param _raffleId: id of the raffle
    /// @param _id: id of the price structure (package)
    function buyEntry(bytes32 _raffleId, uint48 _id) external {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        if (entryInfo.status != STATUS.ACCEPTED) revert NotInAcceptedStatus();

        PriceStructure memory priceStruct = pricesList[_raffleId][_id];
        IERC20 usdc = IERC20(usdcContractAddress);

        uint256 price = priceStruct.price;
        if (usdc.allowance(msg.sender, address(this)) < price)
            revert USDCAllowanceTooLow();

        if (!usdc.transferFrom(msg.sender, address(this), price))
            revert USDCTransferFailed();

        uint48 numEntries = priceStruct.numEntries;
        entriesList[_raffleId].push(
            EntriesBought({
                player: msg.sender,
                currentEntriesLength: entryInfo.entriesLength + numEntries,
                priceStructureId: _id,
                sender: address(this),
                messageId: bytes32(0)
            })
        );

        // update raffle variables
        entryInfo.amountRaised += price; //total amount raised in wei
        entryInfo.entriesLength += numEntries; //total entries bought

        raffleChainActions[_raffleId][address(this)].hasActivity = true;
        raffleChainActions[_raffleId][address(this)].amount += price;

        //add block timestamp to the raffle
        emit EntrySold(_raffleId, msg.sender, entryInfo.entriesLength, _id, "");
    }

    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber Generated by chainlink
    /// @return the wallet that won the raffle
    function getWinnerAddressFromRandom(
        bytes32 _raffleId,
        uint256 _normalizedRandomNumber
    ) public view returns (address) {
        uint256 position = findUpperBound(
            entriesList[_raffleId],
            _normalizedRandomNumber
        );

        return entriesList[_raffleId][position].player;
    }

    /// @param array sorted array of EntriesBought. CurrentEntriesLength is the numeric field used to sort
    /// @param element uint256 to find. Goes from 1 to entriesLength
    /// @dev based on openzeppelin code (v4.0), modified to use an array of EntriesBought
    /// Searches a sorted array and returns the first index that contains a value greater or equal to element.
    /// If no such index exists (i.e. all values in the array are strictly less than element), the array length is returned. Time complexity O(log n).
    /// array is expected to be sorted in ascending order, and to contain no repeated elements.
    /// https://docs.openzeppelin.com/contracts/3.x/api/utils#Arrays-findUpperBound-uint256---uint256-
    function findUpperBound(
        EntriesBought[] storage array,
        uint256 element
    ) internal view returns (uint256) {
        if (array.length == 0) {
            return 0;
        }

        uint256 low = 0;
        uint256 high = array.length;

        while (low < high) {
            uint256 mid = Math.average(low, high);

            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)
            // because Math.average rounds down (it does integer division with truncation).
            if (array[mid].currentEntriesLength > element) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }

        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.
        if (low > 0 && array[low - 1].currentEntriesLength == element) {
            return low - 1;
        } else {
            return low;
        }
    }

    function setWinnerActions(
        bytes32 _raffleId
    ) internal returns (EntryInfoStruct memory) {
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        // RaffleStruct storage raffle = raffles[_raffleId];
        FundingStructure storage funding = fundingList[_raffleId];
        // Check if the raffle is already accepted or is called again because early cashout failed
        if (entryInfo.status != STATUS.ACCEPTED) revert RaffleInWrongStatus();
        if (entryInfo.amountRaised < funding.minimumFundsInWei)
            revert NotEnoughFundsRaised();

        entryInfo.status = STATUS.CLOSING_REQUESTED;

        emit SetWinnerTriggered(_raffleId, entryInfo.amountRaised);
        return entryInfo;
    }

    function requestRandomNumberFromVRF(
        uint32 callbackGasLimit,
        uint16 requestConfirmations,
        uint32 numWords
    ) internal returns (uint256) {
        if (LinkTokenInterface(link).balanceOf(address(this)) < fee) {
            revert InsufficientLinkBalance();
        }

        uint256 requestId = COORDINATOR.requestRandomWords(
            keyHash,
            subscriptionId,
            requestConfirmations,
            callbackGasLimit,
            numWords
        );

        return requestId;
    }

    /// @param _raffleId Id of the raffle
    /// @dev it triggers Chainlink VRF2 consumer, and generates a random number that is normalized and checked that corresponds to a player
    function setWinner(
        bytes32 _raffleId,
        uint32 callbackGasLimit,
        uint16 requestConfirmations,
        uint32 numWords
    ) external nonReentrant {
        if (!isOwner()) revert NotTheOwner();

        EntryInfoStruct memory raffle = setWinnerActions(_raffleId);

        uint256 requestId = requestRandomNumberFromVRF(
            callbackGasLimit,
            requestConfirmations,
            numWords
        );

        chainlinkRaffleInfo[requestId] = RaffleInfo({
            id: _raffleId,
            size: raffle.entriesLength
        });
    }

    /// @param _newAddress new address of the platform wallet
    function setDestinationAddress(address payable _newAddress) external {
        if (!isOwner()) revert NotTheOwner();
        destinationWallet = _newAddress;
    }

    function getRafflesEntryInfo(
        bytes32 _raffleId
    ) public view returns (EntryInfoStruct memory) {
        return rafflesEntryInfo[_raffleId];
    }

    function setUSDCTokenAddress(address _usdcContractAddress) external {
        if (!isOwner()) revert NotTheOwner();

        usdcContractAddress = _usdcContractAddress;
    }

    /// @dev Handles a received CCIP message, processes it, and acknowledges its receipt.
    /// This internal function is called upon the receipt of a new message via CCIP from an allowlisted source chain and sender.
    /// @param message The CCIP message received
    function _ccipReceive(
        Client.Any2EVMMessage memory message
    )
        internal
        override
        onlyAllowlisted(
            message.sourceChainSelector,
            abi.decode(message.sender, (address))
        ) // Make sure source chain and sender are allowlisted
    {
        uint8 messageType = abi.decode(message.data, (uint8));

        if (messageType == uint8(MESSAGE_TYPE.CREATE_RAFFLE_FROM_SIDECHAIN)) {
            _createRaffleFromSidechain(message);
        }

        if (messageType == uint8(MESSAGE_TYPE.BUY_ENTRY)) {
            _buyEntryFromSidechain(message);
        }

        if (messageType == uint8(MESSAGE_TYPE.IS_REFUNDABLE)) {
            _handleIsRefundable(message);
        }

        if (messageType == uint8(MESSAGE_TYPE.IS_RAFFLE_CREATED)) {
            _handleIsRaffleCreated(message);
        }
    }

    function _handleIsRaffleCreated(
        Client.Any2EVMMessage memory message
    ) internal {
        bytes32 messageIdSourceChain = message.messageId;
        uint64 sourceChainSelector = message.sourceChainSelector;
        address sender = abi.decode(message.sender, (address));

        (uint8 messageTypeReceived, bytes32 raffleId, uint256 gasLimitAck) = abi
            .decode(message.data, (uint8, bytes32, uint256));

        bool isRaffleCreated = raffles[raffleId].deadline != 0;

        MESSAGE_TYPE messageType = MESSAGE_TYPE.IS_RAFFLE_CREATED;
        bytes memory data = abi.encode(messageType, raffleId, isRaffleCreated);

        sendMessage(sourceChainSelector, sender, data, gasLimitAck);

        emit IsRaffleCreatedCCIP(
            raffleId,
            isRaffleCreated,
            messageIdSourceChain
        );
    }

    function _handleIsRefundable(
        Client.Any2EVMMessage memory message
    ) internal {
        bytes32 messageIdSourceChain = message.messageId;
        uint64 sourceChainSelector = message.sourceChainSelector;
        address sender = abi.decode(message.sender, (address));

        (
            uint8 messageTypeReceived,
            bytes32 raffleId,
            bytes32 messageId,
            uint256 gasLimitAck,
            address player
        ) = abi.decode(
                message.data,
                (uint8, bytes32, bytes32, uint256, address)
            );

        bool isRefundable = !ticketsBoughtCCIP[raffleId][messageId];

        MESSAGE_TYPE messageType = MESSAGE_TYPE.IS_REFUNDABLE;
        bytes memory data = abi.encode(
            messageType,
            raffleId,
            isRefundable,
            messageId,
            player
        );

        sendMessage(sourceChainSelector, sender, data, gasLimitAck);

        emit IsRefundableCCIP(
            raffleId,
            isRefundable,
            messageIdSourceChain, //track send receive for current message
            messageId //messageId of the bought ticket for which we check if its refundable
        );
    }

    function _createRaffleFromSidechain(
        Client.Any2EVMMessage memory message
    ) internal {
        //create raffle from side chain with prize on side chain and ack back to side chain
        bytes32 messageIdSourceChain = message.messageId;
        // bytes32 messageIdSourceChain = 0x894cccafe7a46ef3ce0297f766eb759c3aa439ab77472626d2ba98088308cee4;

        (
            uint8 messageTypeReceived,
            uint128 minimumFundsInWei,
            PriceStructure[] memory prices,
            uint256 deadline,
            address seller,
            bytes32 raffleId
        ) = abi.decode(
                message.data,
                (uint8, uint128, PriceStructure[], uint256, address, bytes32)
            );

        _createRaffle(
            address(0),
            0,
            minimumFundsInWei,
            prices,
            ASSET_TYPE.CCIP,
            deadline,
            seller,
            raffleId
        );

        address _sender = abi.decode(message.sender, (address));

        raffleChainActions[raffleId][_sender].hasActivity = true;

        emit RaffleCreatedFromSidechain(
            raffleId,
            _sender,
            messageIdSourceChain
        );
    }

    function sendMessage(
        uint64 chainSelector,
        address receiver,
        bytes memory data,
        uint256 gasLimit
    ) internal returns (bytes32 messageId) {
        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({
            receiver: abi.encode(receiver),
            data: data,
            tokenAmounts: new Client.EVMTokenAmount[](0),
            extraArgs: Client._argsToBytes(
                Client.EVMExtraArgsV1({gasLimit: gasLimit})
            ),
            feeToken: link
        });

        // Calculate the fee
        uint256 feeCCIP = IRouterClient(router).getFee(chainSelector, message);

        // Approve the router to spend the fee
        LinkTokenInterface(link).approve(router, feeCCIP);

        // Send the message via CCIP
        messageId = IRouterClient(router).ccipSend(chainSelector, message);

        return messageId;
    }

    function _buyEntryFromSidechain(
        Client.Any2EVMMessage memory message
    ) internal {
        bytes32 messageIdSourceChain = message.messageId;
        uint64 sourceChainSelector = message.sourceChainSelector;
        address sender = abi.decode(message.sender, (address));

        (
            uint8 messageTypeReceived,
            bytes32 raffleId,
            address buyer,
            uint256 priceStructureId
        ) = abi.decode(message.data, (uint8, bytes32, address, uint256));

        _buyEntryCCIP(
            raffleId,
            priceStructureId,
            buyer,
            messageIdSourceChain,
            sender
        );
    }

    function _buyEntryCCIP(
        bytes32 _raffleId,
        uint256 _priceStructureId,
        address _buyer,
        bytes32 _messageIdSourceChain,
        address _sender
    ) internal {
        PriceStructure memory priceStruct = pricesList[_raffleId][
            _priceStructureId
        ];

        uint48 numEntries = priceStruct.numEntries;
        uint256 usdcAmount = priceStruct.price;

        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];

        uint48 entriesLength = entryInfo.entriesLength;

        EntriesBought memory entryBought = EntriesBought({
            player: _buyer,
            currentEntriesLength: uint48(entriesLength + numEntries),
            priceStructureId: uint48(_priceStructureId),
            sender: _sender,
            messageId: _messageIdSourceChain
        });
        entriesList[_raffleId].push(entryBought);

        // update raffle variables
        entryInfo.amountRaised += usdcAmount;
        entryInfo.entriesLength += numEntries;

        raffleChainActions[_raffleId][_sender].hasActivity = true;
        raffleChainActions[_raffleId][_sender].amount += usdcAmount;

        ticketsBoughtCCIP[_raffleId][_messageIdSourceChain] = true;

        //TODO: say that its coming from sidechain and what sidechain
        emit EntrySoldCCIP(
            _raffleId,
            _buyer,
            entriesLength,
            _priceStructureId,
            _messageIdSourceChain
        );
    }

    // The operator can add free entries to the raffle
    /// @param _raffleId Id of the raffle
    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie
    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user
    function giveBatchEntriesForFree(
        bytes32 _raffleId,
        address[] memory _freePlayers
    ) external {
        if (!isOwner()) revert NotTheOwner();
        EntryInfoStruct storage entryInfo = rafflesEntryInfo[_raffleId];
        if (entryInfo.status != STATUS.ACCEPTED) revert NotInAcceptedStatus();

        uint256 freePlayersLength = _freePlayers.length;
        uint48 validPlayersCount = 0;
        for (uint256 i = 0; i < freePlayersLength; i++) {
            address entry = _freePlayers[i];
            // add a new element to the entriesBought array.
            // as this method only adds 1 entry per call, the amountbought is always 1
            EntriesBought memory entryBought = EntriesBought({
                player: entry,
                currentEntriesLength: uint48(entryInfo.entriesLength + i + 1),
                priceStructureId: 0,
                sender: address(this),
                messageId: bytes32(0)
            });
            entriesList[_raffleId].push(entryBought);
            ++validPlayersCount;
        }

        entryInfo.entriesLength = entryInfo.entriesLength + validPlayersCount;

        emit FreeEntry(
            _raffleId,
            _freePlayers,
            freePlayersLength,
            entryInfo.entriesLength
        );
    }
}
